, { optional: [ { RtpDataChannels: true } ]}つける 

概要
最近webRTCを利用したサービスがリリースされ始めている。

筆者はP2P通信を可能にするwebRTCのRTCDataChannelに着目し、通信検証を主な目的として簡単なMO(Multiplayer Online)レースゲームを開発した。

アプリサーバはNode.jsで実装。クライアントはwebGLを利用して3Dビジュアルなゲームになっている。

本レポートは開発の詳細とwebRTCの今後の可能性についてまとめたものである。
タイトルBOX RACER α版ジャンルレースゲーム1レースあたりの参加人数最大4人遊び方矢印キーで車体移動 

コースを先に3周したほうが勝ち開発環境ブラウザ GoogleChrome v26+
言語 Javascript 
エディタ　adobe edge code
使用ライブラリ three.js / binary.js動作環境OS Windows/MacOSX 

ブラウザ GoogleChrome v26+
目次


   * 概要
   * 目次
   * webRTCとは
   * 
      * webSocketとの違い
      * 仕様
      * ブラウザ対応状況
   * 事前知識
   * 
      * NAT越え
      * STUN
      * 端末間通信開始までのフロー
   * アプリケーションサーバ
   * 
      * PeerMORGServer.js
      * 
         * 使用方法
   * クライアント
   * 
      * PeerMORGClient.js
      * 
         * 使用方法
   * パフォーマンス検証
   * 
      * webSocket通信との比較
      * 送信データのバイナリ化
      * レンダリング処理の軽減
   * まとめ
   * 参考資料

webRTCとは
webRTCとは「Web Real-Time Communications」の略語であり、ブラウザ間でリアルタイムなコミュニケーションを可能にする技術仕様の総称である。

現在Googleによってオープンソース化され、IETFがプロトコルを、W3CがAPIの標準化を進めている。

公式サイトには以下のリンクから飛べるので見てみるとよいだろう。

http://www.webrtc.org/
webRTCを使うと以下の事が可能となる。

   * ブラウザでのビデオ･音声チャット
   * ブラウザでのテキストチャット
   * ブラウザでのMOゲームなど

特に目新しい技術ではないが、プラグインなど余計なモジュールを使わずブラウザのみで実現可能となるのがこれまでと違う点だ。
webSocketとの違い
ブラウザでのリアルタイムコミュニケーションと聞くと、webSocketを思い浮かべる方も少なくないだろうが、この二つには大きな違いがある。

webSocketがサーバを介してデータをやり取りする(fig1)のに対して、webRTCはブローカーサーバを必要とするものの、P2P通信を利用して端末間でデータをやり取り(fig2)することができる。

また、webSocketが通信にTCPプロトコルを用いるのに対してwebRTCではUDPプロトコルを利用する。これによって通信速度の向上も見込める。
 
仕様
webRTCには大きく二つの仕様がある。

   * Media Capture and Streams
   * WebRTC 1.0: Real-time Communication Between Browsers

まずMedia Capture and Streamsだが、これはローカルPCのカメラ/マイクからストリームデータを取得する仕様であり、getUserMediaを利用することでストリームデータをやり取りすることが可能となる。

もう一方はP2P通信のための仕様が定義されており、DataChannelを使用する事でP2Pでのデータ通信が可能となる。ただし、こちらはまだブラウザへの実装が進んでおらず現在はChromeとFirefoxのみ利用可能となっている。
ブラウザ対応状況
MediaStream and getUserMedia

   * Chrome desktop 18.0.1008+; Chrome for Android 29+
   * Opera, Opera Mobile 12
   * Firefox 17+

RTCPeerConnection

   * Chrome desktop 20+ (now 'flagless', i.e. no need to set about:flags); Chrome for Android 29+ (flagless)
   * Firefox 22+ (on by default)

RTCDataChannel

   * Experimental version in Chrome 25, more stable (and with Firefox interoperability) in Chrome 26+; Chrome for Android 29+
   * Firefox 22+ (on by default)



事前知識NAT越え
開発の詳細に入る前にP2P通信を考える上において知っておかなければならない「NAT越え」について軽く触れておきたい。まずNATとは、LAN内で使用する端末のプライベートIPアドレスと、それに対応するインターネット上のグローバルIPアドレスを１対１で相互変換する技術のことを言う。通常ルーターなどがこの役割を担うが、インターネット側からNAT配下の特定の端末にアクセスしたいとき、どの端末なのか識別できないという問題がでてくる。これを解決する技術が「NAT越え」である。P2P通信のように端末間で直接やり取りする場合は、このNAT越えをクリアしなければ通信経路が確立できないのである。

このNAT越えを実現する仕組みの一つにIETFが開発したICE(Interactive Connectivity Establishment)というものがある。

これはSTUNやTURNを含む多くのプロトコルを使いそれを実現している。
STUN
STUNサーバというグローバルIPアドレスを持つサーバを用い、NAT配下の端末がSTUNサーバと通信することで自分のWAN側のIPアドレスとポート番号のペアをSTANサーバに記録させておく。これによって別ネットワーク間の端末同士がSTUNサーバに記録された各々のWAN側のIPアドレス情報をたよりに、通信可能にする仕組みのことである。これはRFC3489で定義されている。

使用可能なSTUNサーバリスト

https://code.google.com/p/natvpn/source/browse/trunk/stun_server_list
NAT越えについてより詳しく知りたい方はこちらの資料が参考になるだろう。

以上のことを踏まえて、webRTCによるP2P通信の具体的な実装方法を見ていこう。
端末間通信開始までのフロー
端末間のP2P通信接続までのフローと、具体的な実装方法は大まかに以下のようになる。

登場するのはcaller(送信元)とcallee(送信先)端末だ。DataConnectionオブジェクトは

送信元のほうで1つ作っておけば送信先では作らなくてもよい。

  1. caller(送信元)がSTUNサーバにアクセスして接続先情報を要求する。




var config = {
    "iceServers":[
        {"url":"stun:stun.example.org"}
    ]
};
 
//RTCPeerConnectionオブジェクトを生成
//
var pc =newRTCPeerConnection(config,, { optional: [ { RtpDataChannels: true } ]});
 
//RTCDataChannelオブジェクトを生成
var dc = pc.createDataChannel('ラベル名',{reliable:false});
  2. callerがオファー（通信依頼）を作成し、アプリケーションサーバへ送信する。




//create offer
pc.createOffer(function(description){
    pc.setLocalDescription(description);
    //send offer to broker server by XHR
    send(JSON.stringify({
        "sdp": description
    }));
});
  3. callee(送信先)がアプリケーションサーバからオファーを受信する。




//受信したオファー（sdp）
var sdp =newRTCSessionDescription(sdp);
pc.setRemoteDescription(sdp,function(){
    if(pc.remoteDescription.type =="offer") {
        //アンサーを作成
    }
});
 
//callee側でもRTCPeerConnectionオブジェクトを生成する。
//caller側でRTCDataChannelオブジェクトが生成されたタイミングで
//pc.ondatachannelが呼ばれるのでこの中でDataChannelを受け取ることができる。
var pc =newRTCPeerConnection(config,, { optional: [ { RtpDataChannels: true } ]});
pc.ondatachannel = function(e) {
   　var dc = e.channel;
};
  4. calleeがSTUNサーバから接続先情報を取得する。




pc.onicecandidate = function(e) {
    var candidate = e.candidate;
    if(candidate) {
       //アプリケーションサーバへ通知
    };
}
  5. calleeがアンサー（通信許可）を作成し、アプリケーションサーバへ送信する。




//create answer
pc.createAnswer(function(description){
    pc.setLocalDescription(description);
    //send answer to broker server by WS
    send(JSON.stringify({
        "sdp": description
    }));
});
  6. callerがアプリケーションサーバからアンサーを受信する。




//受信したアンサー（sdp）
var sdp =newRTCSessionDescription(sdp)
pc.setRemoteDescription(sdp,function(){
    if(pc.remoteDescription.type =="answer") {
        //do something
    }
})
  7. callerがデータを送信




dc.send(data);
  8. calleeがデータを受信




dc.on('data', function(data) {
    console.log(data);
});


http://dev.w3.org/2011/webrtc/editor/webrtc.html

アプリケーションサーバ
まず、サーバ側だが今回のゲーム開発用に自作ライブラリを用意した。これは、STUNサーバから取得した接続先情報の受け渡しとレース一覧情報の管理、接続中のクライアント情報の管理などを担う。npmモジュールとして公開しているのでどなたでも利用可能となっている。
PeerMORGServer.js
GHE

http://ghe.amb.ca.local/takata-tomoyuki/PeerMORGServer
使用方法
モジュールのインストール


npm install peer-morg-server
app.jsを作成


var peerMORGServer = require('peer-morg-server').PeerMORGServer;

var server = new peerMORGServer();
サーバを起動


forever start app.js
クライアント
クライアント側も同様にライブラリを用意した。webRTCのDataChannelを利用して複数人でのP2P通信が可能になる。

送信データはJSONオブジェクトで行うようにしている。
PeerMORGClient.js
GHE

http://ghe.amb.ca.local/takata-tomoyuki/PeerMORGClient
使用方法
ファイルの読み込み


<script src="./js/lib/peerMORGClient.js"></script>
PeerMORGClientオブジェクトを生成


peer = new PeerMORGClient();
ゲームへの参加


peer.join(params);
データ送信(P2P)


peer.sendData(json)
イベントをリッスン


//アプリケーションサーバとの接続成功時

peer.on('open',function(data){
});
//他ユーザーのレース参加時

peer.on('join',function(data){
});
//レース開始までの秒数取得時

peer.on('countdown',function(data){
});
//レーススタート時

peer.on('start',function(data){
});
//データ取得時(P2P)

peer.on('data',function(data){
});
//タイムアウト時

peer.on('timeout',function(data){
});
//エラー時

peer.on('error',function(data){
});





chromeのwebRTC Developperツールを利用すれば、オファー/アンサーの流れとcandidateの詳細を確認できる。
chrome://webrtc-internals

ゲームを立ち上げツールを起動すると、実際にDataChannelセッションの状態を確認できた。






パフォーマンス検証
webSocket通信との比較
ブラウザでのMOゲームを考える時、webSocketとwebRTCのどちらを利用する方がよいのか疑問だったので
実際にwebSocket通信版を実装し、通信時間の比較検証を行った。


検証方法
一台のPC端末でブラウザを二つ立ち上げ、ブラウザAのデータ送信時の現在時刻とブラウザBのデータ受信時の現在時刻の時間差を計測した。これを30回計測したものを1セットとし、合計3セット分の平均値を下の表にまとめた。


検証環境
OS : MacOS X 10.7.4
プロセッサ　1.86 GHz Core 2 Duo
メモリ　4G
サーバー　localhost


websocket


20 index.html:595
9 index.html:595
4 index.html:595
6 index.html:595
4 index.html:595
11 index.html:595
13 index.html:595
9 index.html:595
3 index.html:595
13 index.html:595
8 index.html:595
21 index.html:595
4 index.html:595
21 index.html:595
5 index.html:595
23 index.html:595
34 index.html:595
6 index.html:595
36 index.html:595
16 index.html:595
9 index.html:595
4 index.html:595
13 index.html:595
8 index.html:595
3 index.html:595
11 index.html:595

dataconnection

6 index.html:590
7 index.html:590
5 index.html:590
7 index.html:590
5 index.html:590
5 index.html:590
7 index.html:590
5 index.html:590
6 index.html:590
7 index.html:590
6 index.html:590
6 index.html:590
6 index.html:590
5 index.html:590
6 index.html:590
4 index.html:590
6 index.html:590
6 index.html:590
7 index.html:590
6 index.html:590
5 index.html:590
6 index.html:590
6 index.html:590

この表を折れ線グラフ化したものが以下である。



考察
グラフからも分かるようにwebSocketの通信時間はdatachannelに比べてばらつきがあった。
datachannelのほうは平均して10msいかない程度の低いレイテンシを保っている。
平均msは　とdatachannelのほうが　ms結果となった。
今回検証したサーバーはlocalhostだったため、これがクラウドなどリージョンによって左右される環境にある場合
本計測時間よりも大きな差がでるのではないかと考える。

ではdatachannelを選択するのが良いのかと言えば他にも考慮すべき点はある。
webSocketが使っているTCPプロトコルはデータ送信を確実に保証する。
一方datachannelはUDPプロトコルでの通信のため、データ送信が途中で失敗しても構わず次の送信へうつる。
よって送信処理の信頼性よりも到達速度を重視したい場合はDataChannel(UDP)を選択すべきというのが現状の考えである。
もう一点はP2P通信でのMOゲームを考える場合、クライアント側にソースコードが集中するため、多くの機能をクライアント側に詰め込む必要がある。この点も勘案したいところだ。

送信データ


データの送信にはRTCDatachannelのsendメソッドを使う。
現在の仕様で定義されている送信可能なデータ型は以下の４つである。


   * 
string object:
   * 
Blob object:
   * 
ArrayBuffer object:
   * 
ArrayBufferView object: 


BoxKartでは自分の座標と方向の情報をJSONオブジェクトとして定義し、やりとりしている。

example : 
{ dir: 0.9 , x : 100 , y : 30 , z : 300 }

今現在Chromeはバイナリ送信に対応していないためStringオブジェクトで送る必要があった。
方法としては、JSON.stringifyメソッドでJSONオブジェクトを文字列に変換し、受信側で復元している。
webRTCのライブラリとして有名なPeerJSでは、JSONオブジェクトを一度Blobデータにし、それをStringに変換し
て送信している。

どちらの方法がよいのか検証してみた。

4 index.html:592
4 index.html:592
4 index.html:592
3 index.html:592
1 index.html:592
5 index.html:592
4 index.html:592
2 index.html:592
1 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
4 index.html:592
3 index.html:592
2 index.html:592
3 index.html:592
6 index.html:592
4 index.html:592
4 index.html:592
3 index.html:592
4 index.html:592
3 index.html:592
2 index.html:592
4 index.html:592
5 index.html:592
3 index.html:592


7 index.html:590
5 index.html:590
6 index.html:590
4 index.html:590
8 index.html:590
5 index.html:590
6 index.html:590
6 index.html:590
9 index.html:590
7 index.html:590
6 index.html:590
4 index.html:590
6 index.html:590
4 index.html:590
6 index.html:590
7 index.html:590
6 index.html:590
6 index.html:590
6 index.html:590
6 index.html:590
6 index.html:590
6 index.html:590
5 index.html:590
6 index.html:590
6 index.html:590
8 index.html:590
5 index.html:590
6 index.html:590

見ての通りでほとんど目立った差はなかった。
あまり有用な検証結果は得られなかったため、JSON.stringifyで実装している。
まとめ

今回作ったアプリでは、webRTCを利用したブラウザ間通信の検証がメインの目的だったためwebGLの描画処理の軽減やメモリ対策、レイテンシへの対応などは実装されていない。それでもRTCDatachannelによる送受信速度とそれに伴う負荷が
思った以上に低かったため、さほどきにならない程度にゲームを楽しめるように思う。（4つの車体が画面内で並走した場合、描画負荷が高まりところどころ処理落ちする部分があったが）


webGLもwebRTCもいずれ携帯端末で標準サポートされる日が来るだろうと思っているが、携帯端末のスペックが上がっていけば、携帯ブラウザでもMOゲームは十分可能になりそうだ。


今回作ったライブラリに関しては、引き続きバグフィックスとソースの改善を行っていくつもりだ。
また、TODO事項としてモジュールの設計がレースゲームに特化した作りとなってしまっているため、ゲームジャンルを問わないAPI設計にし汎用的に使えるものにしなければならない。


webRTCはまだまだ新しい技術なので、その将来性と可能性は広がっている。
今後もその動向に注目し、webの未来を探っていきたい。
参考資料

   * http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcdatachann...
   * http://flashrealtime.com/download/MAX_2010_Building-P2P-Multiplayer-Games.pdf
   * https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/
